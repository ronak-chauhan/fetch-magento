import binasciiimport requestsfrom odoo import _, api, fields, modelsfrom .res_partner import _unescapeclass ProductProduct(models.Model):    _inherit = 'product.product'    mob_mapping_ids = fields.One2many(        string='Mappings',        comodel_name='magento.product',        inverse_name='pro_name',        copy=False    )    @api.model    def create(self, vals):        ctx = dict(self._context or {})        instanceId = ctx.get('instance_id')        if 'magento' in ctx:            mageId = vals.pop('mage_id', 0)            magento_stock_id = vals.pop('magento_stock_id', 0)            attrValIds = vals.get('value_ids', [])            vals = self.update_vals(vals, instanceId, True)        productObj = super(ProductProduct, self).create(vals)        if 'magento' in ctx:            productObj.create_magent_product(vals, mageId, magento_stock_id,                                             attrValIds)        return productObj    def create_magent_product(self, vals, mageId, magento_stock_id,                              attrValIds):        ctx = dict(self._context or {})        instanceId = ctx.get('instance_id')        mapTempModel = self.env['magento.product.template']        if 'magento' in ctx and self.exists():            attrValModel = self.env['product.attribute.value']            attrLineModel = self.env['product.template.attribute.line']            productAttrValModel = self.env['product.template.attribute.value']            templateId = self.product_tmpl_id.id            if templateId:                mappDict = {                    'instance_id' : instanceId,                    'created_by' : 'Magento',                }                domain = [('product_tmpl_id', '=', templateId)]                for attrValId in attrValIds:                    attrId = attrValModel.browse(attrValId).attribute_id.id                    searchDomain = domain + [('attribute_id', '=', attrId)]                    attrLineObjs = attrLineModel.search(searchDomain)                    if not attrLineObjs:                        attrLineObjs = attrLineModel.create({'attribute_id':                                                                 attrId,                                                             'product_tmpl_id': templateId})                    for attrLineObj in attrLineObjs:                        if attrValId not in attrLineObj.value_ids.ids:                            attrLineObj.value_ids = [(4, attrValId)]                        productAttrValObj = productAttrValModel.search(                            [('product_attribute_value_id', '=', attrValId),                             ('attribute_line_id', '=', attrLineObj.id),                             ('product_tmpl_id', '=', templateId)])                        if not productAttrValObj:                            pavm_id = productAttrValModel.create({                                'product_attribute_value_id': attrValId,                                'attribute_line_id': attrLineObj.id,                                'product_tmpl_id': templateId                            })                            self._cr.execute("insert into "                                             "product_variant_combination("                                             "product_product_id,"                                             "product_template_attribute_value_id) values({}, {})".format(self.id, pavm_id.id))                        else:                            if productAttrValObj:                                if self.id not in \                                        productAttrValObj.ptav_product_variant_ids.ids:                                    self._cr.execute("insert into "                                                     "product_variant_combination("                                                     "product_product_id,"                                                     "product_template_attribute_value_id) values({}, {})".format(                                    self.id, productAttrValObj[0].id))                                    # self._cr.commit()                        #     pavm_id.ptav_product_variant_ids = [(4, self.id)]                        # else:                        #     if productAttrValObj:                        #         productAttrValObj[                        #             0].ptav_product_variant_ids = [(4, self.id)]                if mageId:                    mapTempObjs = mapTempModel.search([                        ('erp_template_id', '=', templateId),                        ('instance_id', '=', instanceId)                    ])                    if not mapTempObjs:                        price = vals.get('list_price', 0)                        mapTempDict = mappDict.copy()                        mapTempDict.update({                            'template_name' : templateId,                            'erp_template_id' : templateId,                            'mage_product_id' : mageId,                            'base_price' : price,                        })                        mapTempModel.create(mapTempDict)                    else:                        mapTempObjs.need_sync = 'No'                    if self.exists():                        mappDict.update({                            'pro_name' : self.id,                            'oe_product_id' : self.id,                            'mag_product_id' : mageId,                            'magento_stock_id' : magento_stock_id                        })                    self.env['magento.product'].create(mappDict)        return True    def write(self, vals):        ctx = dict(self._context or {})        instanceId = ctx.get('instance_id', False)        mapProdModel = self.env['magento.product']        mapTempModel = self.env['magento.product.template']        if 'magento' in ctx:            vals.pop('mage_id', None)            vals.pop('magento_stock_id', None)            vals = self.update_vals(vals, instanceId)        for prodObj in self:            mapObjs, tempMapObjs = [], []            mapObjs = mapProdModel.search([('pro_name', '=', prodObj.id)])            for mappedObj in mapObjs:                if instanceId and mappedObj.instance_id.id == instanceId:                    mappedObj.need_sync = "No"                else:                    mappedObj.need_sync = "Yes"            templateId = prodObj.product_tmpl_id.id            tempMapObjs = mapTempModel.search(                [('template_name', '=', templateId)])            for tempMapObj in tempMapObjs:                if instanceId and tempMapObj.instance_id.id == instanceId:                    tempMapObj.need_sync = "No"                else:                    tempMapObj.need_sync = "Yes"        return super(ProductProduct, self).write(vals)    def update_vals(self, vals, instanceId, create=False):        if vals.get('default_code'):            vals['default_code'] = _unescape(vals['default_code'])        category_ids = vals.pop('category_ids', None)        if category_ids:            categIds = list(set(category_ids))            defaultCategObj = self.env["magento.configure"].browse(                instanceId).category            if defaultCategObj and create:                vals['categ_id'] = defaultCategObj.id            vals['categ_ids'] = [(6, 0, categIds)]        attrValIds = vals.pop('value_ids', [])        # if attrValIds:        #     vals['product_template_attribute_value_ids'] = [(6, 0, attrValIds)]        tmpl_id = False        if 'product_tmpl_id' in vals:            tmpl_id = self.env['product.template'].browse(vals['product_tmpl_id'])        if tmpl_id:            attrValModel = self.env['product.attribute.value']            attrLineModel = self.env['product.template.attribute.line']            productAttrValModel = self.env['product.template.attribute.value']            templateId = tmpl_id.id            if templateId:                domain = [('product_tmpl_id', '=', templateId)]                for attrValId in attrValIds:                    attrId = attrValModel.browse(attrValId).attribute_id.id                    searchDomain = domain + [('attribute_id', '=', attrId)]                    attrLineObjs = attrLineModel.search(searchDomain)                    if not attrLineObjs:                        attrLineObjs = attrLineModel.create(                            {'attribute_id': attrId,                             'product_tmpl_id': templateId})                    for attrLineObj in attrLineObjs:                        if attrValId not in attrLineObj.value_ids.ids:                            attrLineObj.value_ids = [(4, attrValId)]                        productAttrValObj = productAttrValModel.search(                            [('product_attribute_value_id', '=',attrValId),                             ('attribute_line_id', '=', attrLineObj.id),                             ('product_tmpl_id', '=', templateId)])                        if productAttrValObj:                            if 'product_template_attribute_value_ids' in vals:                                vals[                                    'product_template_attribute_value_ids'] \                                    += productAttrValObj.ids                            else:                                vals['product_template_attribute_value_ids'] = productAttrValObj.ids        imageUrl = vals.pop('image_url', False)        if imageUrl:            proImage = binascii.b2a_base64(requests.get(imageUrl).content)            vals['image_1920'] = proImage        return valsclass ProductCategory(models.Model):    _inherit = 'product.category'    def write(self, vals):        if 'magento' in self._context:            if vals.get('name'):                vals['name'] = _unescape(vals['name'])        else:            categModel = self.env['magento.category']            for catObj in self:                mapObjs = categModel.search(                    [('oe_category_id', '=', catObj.id)])                for mapObj in mapObjs:                    mapObjs.need_sync = "Yes"        return super(ProductCategory, self).write(vals)